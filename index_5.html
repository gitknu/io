<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>BirdChat Offline üê¶</title>
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Offline Audio Chat using Bird Sounds">
    <style>
        :root {
            --bg: #1a1a1a;
            --header-bg: #000000;
            --text: #e0e0e0;
            --accent: #4caf50;
            --accent-glow: rgba(76, 175, 80, 0.4);
            --msg-bg-in: #2d2d2d;
            --msg-bg-out: #1b5e20;
            --listening: #ff5252;
        }

        * { box-sizing: border-box; }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling the whole page */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            /* Use dynamic viewport height to account for mobile URL bars */
            height: 100dvh; 
        }

        header {
            flex-shrink: 0; /* Never shrink header */
            padding: 15px;
            padding-top: max(15px, env(safe-area-inset-top));
            background: var(--header-bg);
            text-align: center;
            border-bottom: 1px solid #333;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        h1 { margin: 0; font-size: 1.2rem; color: var(--accent); letter-spacing: 1px; }
        #status { font-size: 0.75rem; color: #888; margin-top: 5px; font-family: monospace; transition: color 0.3s; }

        #chat-area {
            flex: 1; /* Take up all available space */
            min-height: 0; /* Crucial for scrolling inside flex items */
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }

        .message {
            max-width: 85%;
            padding: 10px 15px;
            border-radius: 18px;
            font-size: 0.95rem;
            word-wrap: break-word;
            line-height: 1.4;
            animation: popIn 0.3s ease-out;
            position: relative;
        }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .received {
            align-self: flex-start;
            background: var(--msg-bg-in);
            border-bottom-left-radius: 4px;
            color: #fff;
        }

        .sent {
            align-self: flex-end;
            background: var(--msg-bg-out);
            border-bottom-right-radius: 4px;
            color: #fff;
        }

        .sys-msg {
            align-self: center;
            font-size: 0.7rem;
            color: #666;
            background: rgba(0,0,0,0.2);
            padding: 4px 10px;
            border-radius: 10px;
            margin: 10px 0;
        }

        #visualizer {
            flex-shrink: 0;
            height: 4px;
            background: #000;
            width: 100%;
            display: flex;
            justify-content: center;
            overflow: hidden;
        }
        #vis-bar {
            width: 0%;
            background: var(--accent);
            height: 100%;
            transition: width 0.05s ease;
            opacity: 0.7;
        }

        #controls {
            flex-shrink: 0; /* Never shrink controls */
            padding: 15px;
            padding-bottom: max(15px, env(safe-area-inset-bottom)); /* iOS Home bar safe area */
            background: var(--header-bg);
            border-top: 1px solid #333;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 20;
        }

        input {
            flex: 1;
            padding: 12px 15px;
            border-radius: 25px;
            border: 1px solid #444;
            background: #222;
            color: #fff;
            outline: none;
            font-size: 16px; /* Prevents iOS zoom on focus */
            transition: border-color 0.2s;
            min-width: 0; /* Prevents overflow */
        }
        input:focus { border-color: var(--accent); }

        button {
            padding: 0;
            height: 44px;
            border-radius: 22px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #send-btn {
            background: var(--accent);
            color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            width: 50px; /* Fixed width */
        }
        #send-btn:active { transform: scale(0.95); }
        #send-btn:disabled { background: #444; color: #888; cursor: not-allowed; }

        #listen-btn {
            background: #333;
            color: #bbb;
            width: 50px; /* Fixed width */
            border-radius: 50%;
            border: 1px solid #444;
        }
        
        #listen-btn.listening {
            background: var(--listening);
            color: white;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 10px var(--listening);
            border-color: var(--listening);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }

    </style>
</head>
<body>

<header>
    <h1>BirdChat üê¶</h1>
    <div id="status">Tap the Mic to Connect</div>
</header>

<div id="chat-area">
    <div class="sys-msg">Offline Secure Channel</div>
    <div class="message received">Welcome! Ensure volume is UP on both devices.</div>
    <div class="message sent">Press the Mic button below to start.</div>
</div>

<div id="visualizer">
    <div id="vis-bar"></div>
</div>

<div id="controls">
    <button id="listen-btn" title="Toggle Mic">üéôÔ∏è</button>
    <input type="text" id="msg-input" placeholder="Type chirp..." maxlength="150" autocomplete="off">
    <button id="send-btn">‚û§</button>
</div>

<script>
    /**
     *  BIRDCHAT - SINGLE FILE OFFLINE AUDIO MODEM
     *  Technique: FSK (Frequency Shift Keying) with Shaped Envelopes
     *  Bandwidth: Low (~25 bits/s) for reliability over air
     */

    // --- SERVICE WORKER INJECTOR (For Offline Cache) ---
    const swCode = `
        const CACHE_NAME = 'birdchat-v1-single';
        self.addEventListener('install', e => {
            e.waitUntil(self.skipWaiting());
        });
        self.addEventListener('activate', e => {
            e.waitUntil(self.clients.claim());
        });
        self.addEventListener('fetch', e => {
            e.respondWith(
                fetch(e.request)
                .then(res => {
                    const resClone = res.clone();
                    caches.open(CACHE_NAME).then(cache => cache.put(e.request, resClone));
                    return res;
                })
                .catch(() => caches.match(e.request))
            );
        });
    `;
    
    try {
        const blob = new Blob([swCode], {type: 'application/javascript'});
        const blobUrl = URL.createObjectURL(blob);
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register(blobUrl)
                .then(() => console.log('Offline Worker Injecting...'))
                .catch(err => console.log('SW Note:', err));
        }
    } catch(e) { console.log('SW skipped'); }


    // --- APP CONFIGURATION ---
    const FREQ_0 = 3200;       // '0' Bit Hz
    const FREQ_1 = 4800;       // '1' Bit Hz
    const FREQ_START = 2200;   // Wake-up Signal
    const BIT_TIME = 0.045;    // 45ms per bit (slower = more reliable)
    const GAP_TIME = 0.005;    // 5ms silence between bits
    const FFT_SIZE = 2048;

    // --- STATE ---
    let audioCtx = null;
    let analyser = null;
    let micStream = null;
    let isListening = false;
    let processingFrame = 0;

    // --- DOM ---
    const ui = {
        status: document.getElementById('status'),
        chat: document.getElementById('chat-area'),
        input: document.getElementById('msg-input'),
        sendBtn: document.getElementById('send-btn'),
        micBtn: document.getElementById('listen-btn'),
        visBar: document.getElementById('vis-bar')
    };

    // --- AUDIO INIT ---
    async function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        return audioCtx;
    }

    // --- TRANSMITTER (The Chirp) ---
    async function transmit(text) {
        if (!text) return;
        ui.sendBtn.disabled = true;
        ui.input.disabled = true;
        ui.status.innerText = "Transmitting...";
        ui.status.style.color = "var(--accent)";

        await initAudio();

        // 1. Text -> Binary
        let binary = "";
        for (let i = 0; i < text.length; i++) {
            binary += text.charCodeAt(i).toString(2).padStart(8, '0');
        }

        // Add visual bubble immediately
        addMessage(text, 'sent');
        ui.input.value = '';

        const t0 = audioCtx.currentTime + 0.1;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'sine';

        // 2. Schedule Sounds
        let t = t0;

        // Start Signal (Ramp up/down "Squawk")
        osc.frequency.setValueAtTime(FREQ_START, t);
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(1, t + 0.05);
        gain.gain.linearRampToValueAtTime(0, t + 0.2);
        t += 0.3; // Wait before data

        // Data Bits
        for (let bit of binary) {
            const freq = bit === '1' ? FREQ_1 : FREQ_0;
            
            // Set Frequency
            osc.frequency.setValueAtTime(freq, t);
            
            // Envelope (Bird-like pluck)
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.8, t + (BIT_TIME * 0.3));
            gain.gain.exponentialRampToValueAtTime(0.01, t + BIT_TIME);
            
            t += BIT_TIME + GAP_TIME;
        }

        osc.start(t0);
        osc.stop(t + 0.1);

        osc.onended = () => {
            ui.sendBtn.disabled = false;
            ui.input.disabled = false;
            ui.input.focus();
            ui.status.innerText = isListening ? "Listening..." : "Idle";
            ui.status.style.color = "#888";
        };
    }

    // --- RECEIVER (The Ear) ---
    async function toggleMic() {
        await initAudio();

        if (isListening) {
            // Stop
            isListening = false;
            ui.micBtn.classList.remove('listening');
            ui.micBtn.innerHTML = "üéôÔ∏è";
            ui.status.innerText = "Idle";
            ui.status.style.color = "#888";
            if (micStream) {
                micStream.getTracks().forEach(t => t.stop());
                micStream = null;
            }
            ui.visBar.style.width = '0%';
        } else {
            // Start
            try {
                micStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        autoGainControl: false,
                        noiseSuppression: false,
                        latency: 0
                    }
                });

                const src = audioCtx.createMediaStreamSource(micStream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                analyser.smoothingTimeConstant = 0; // React instantly
                src.connect(analyser);

                isListening = true;
                ui.micBtn.classList.add('listening');
                ui.micBtn.innerHTML = "üëÇ";
                ui.status.innerText = "Listening for chirps...";
                ui.status.style.color = "#ccc";
                
                detectLoop();

            } catch (err) {
                alert("Mic Access Denied: " + err.message);
            }
        }
    }

    // --- SIGNAL PROCESSING LOOP ---
    // State Machine
    let rxState = 'IDLE'; // IDLE, RECEIVING
    let bitBuffer = "";
    let lastBitTime = 0;
    let signalLossCount = 0;

    function detectLoop() {
        if (!isListening) return;

        const buffer = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(buffer);

        // Helper: Get Amplitude at Hz
        const nyquist = audioCtx.sampleRate / 2;
        const binSize = nyquist / analyser.frequencyBinCount;
        const getAmp = (freq) => {
            const bin = Math.round(freq / binSize);
            // Sum 3 bins to account for Doppler/Drift
            return Math.max(buffer[bin-1]||0, buffer[bin]||0, buffer[bin+1]||0);
        };

        const ampStart = getAmp(FREQ_START);
        const amp0 = getAmp(FREQ_0);
        const amp1 = getAmp(FREQ_1);

        const THRESHOLD = 60; // Sensitivity
        const now = Date.now();

        // Visualizer
        const maxAmp = Math.max(ampStart, amp0, amp1);
        ui.visBar.style.width = Math.min(100, (maxAmp / 255) * 100) + '%';

        // Logic
        if (rxState === 'IDLE') {
            // Looking for Start Signal
            if (ampStart > THRESHOLD + 20) {
                rxState = 'RECEIVING';
                bitBuffer = "";
                lastBitTime = now + 250; // Wait for start chirp to finish
                signalLossCount = 0;
                ui.status.innerText = "Incoming transmission...";
                ui.status.style.color = "#4caf50";
            }
        } else if (rxState === 'RECEIVING') {
            // Sampling Bits
            // We only sample if enough time passed since last bit
            // Bit duration is ~50ms total. We sample in the middle.
            
            if (now > lastBitTime + (BIT_TIME * 1000)) {
                let bit = null;

                // Simple comparison discriminator
                if (amp1 > THRESHOLD && amp1 > amp0) bit = '1';
                else if (amp0 > THRESHOLD && amp0 > amp1) bit = '0';

                if (bit) {
                    bitBuffer += bit;
                    lastBitTime = now;
                    signalLossCount = 0;
                    ui.visBar.style.backgroundColor = "#fff"; // Flash on bit
                    setTimeout(() => ui.visBar.style.backgroundColor = "var(--accent)", 20);
                } else {
                    signalLossCount++;
                }

                // End of Transmission Detection
                // If we haven't seen a strong bit for ~600ms, assume done
                if (signalLossCount > 12) {
                    processBits(bitBuffer);
                    rxState = 'IDLE';
                    ui.status.innerText = "Listening for chirps...";
                    ui.status.style.color = "#ccc";
                }
            }
        }

        requestAnimationFrame(detectLoop);
    }

    function processBits(bits) {
        if (bits.length < 8) return;

        let text = "";
        for (let i = 0; i < bits.length; i += 8) {
            const byte = bits.substr(i, 8);
            if (byte.length === 8) {
                text += String.fromCharCode(parseInt(byte, 2));
            }
        }

        // Clean garbage
        const cleanText = text.replace(/[^\x20-\x7E]/g, '');
        if (cleanText.length > 0) {
            addMessage(cleanText, 'received');
        }
    }

    function addMessage(text, type) {
        const div = document.createElement('div');
        div.className = `message ${type}`;
        div.innerText = text;
        ui.chat.appendChild(div);
        ui.chat.scrollTo(0, ui.chat.scrollHeight);
        
        // Vibration feedback if supported
        if (navigator.vibrate && type === 'received') navigator.vibrate(200);
    }

    // --- EVENTS ---
    ui.micBtn.addEventListener('click', toggleMic);
    
    ui.sendBtn.addEventListener('click', () => {
        const txt = ui.input.value.trim();
        if (txt) transmit(txt);
    });
    
    ui.input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') ui.sendBtn.click();
    });

    // Auto-init audio context on first interaction
    document.body.addEventListener('click', () => initAudio(), {once:true});

</script>
</body>
</html>
